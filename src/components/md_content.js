// str是md的内容，正常情况下，可以将md上传到服务器，后台将md的内容传回
const str = '# 先上成果图\n\n![](https://user-gold-cdn.xitu.io/2018/11/6/166e830251bbf7ea?w=2852&h=1630&f=png&s=2890302)\n\n# 网页的布局\n网页布局分为三部分，分别是\n- 头部header，固定定位\n- 侧边栏aside，固定定位,margin-top的值是header的高度\n- 内容contain，静态定位, margin-top值为header的高度，margin-left的值为aside的宽度，是router-view的出口。分为两部分：\n    - 主内容，显示md转换后的html页面，margin-right值为md目录的宽度值\n    - 提取markdown的h1和h2目录，用于标题导航，固定定位\n\n# 功能\n为了md能在网页上良好的展示，应具备以下功能：\n1. 点击左侧的菜单，可以获取到相应的md内容（字符串格式），将md内容转成html，为一级、二级标题加锚点id\n2. 为html增加md的格式，引入一个css即可，[参考网址](https://github.com/sindresorhus/github-markdown-css)\n3. 提取md中的一级二级标题，在右侧显示文章目录\n4. 点击右侧文章目录，左侧内容可定位到相应的位置，还要做平滑滚动处理，增强用户体验\n5. 左侧内容滚动时，右侧目录的激活项随之动态变化\n\n## md转成html\n我使用了marked.js将md转成html，并在这里为h1和h2加上了id值，作为锚点\n```\n//  先安装marked.js到本地\nnpm install marked --save\n//  在组件内引入marked\nimport marked from "marked";\n//  marked的基本设置\nmarked.setOptions({\n    renderer: rendererMD,\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: false,\n    smartLists: true,\n    smartypants: false\n});\n//  实例化\nlet rendererMD = new marked.Renderer();\n// 在计算属性中，处理md的h1、h2，加上id值，并使用marked转成html\ncomputed: {\n    compiledMarkdown: function() {\n        let index = 0;\n        rendererMD.heading = function(text, level) {\n            if (level < 3) {\n                return `<h${level} id="${index++}" class="jump" >${text}</h${level}>`;\n            } else {\n                return `<h${level}>${text}</h${level}>`;\n            }\n        };\n        return marked(this.content);\n    }\n}\n```\n在html中，用v-html绑定此计算属性即可\n```\n<div class="markdown-body" ref="content" id="content" v-html="compiledMarkdown">\n```\n## 提取标题\n```\ngetTitle(content) {\n    let nav = [];\n    let navLevel = [1, 2];\n    let tempArr = [];\n    content\n        // 以至少一个井号开始，紧接非换行符外任意个字符进行惰性匹配，然后是一个换行符\n        .replace(/(#+)[^#][^\n]*?(?:\n)/g, function(match, m1) {\n            let title = match.replace("\n", "");\n            let level = m1.length;\n            tempArr.push({\n                title: title.replace(/^#+/, "").replace(/\([^)]*?\)/, ""),\n                level: level,\n                children: []\n            });\n        });\n    //  tempArr得到的是全部1-6级标题，将一级和二级过滤出来\n    nav = tempArr.filter(_ => _.level <= 2);\n    let index = 0;\n    //  在此处加index值，这里和标签里绑定的id是对应的\n    nav = nav.map(_ => {\n        _.index = index++;\n        return _;\n    });\n    let retNavs = [];\n    let toAppendNavList;\n    navLevel.forEach(level => {\n        // 遍历一级和二级标题，将同一级的元素组成一个新数组\n        toAppendNavList = this.find(nav, {\n            level: level\n        });\n        if (retNavs.length === 0) {\n            // 处理一级标题\n            retNavs = retNavs.concat(toAppendNavList);\n        } else {\n            // 处理二级标题，把二级标题加到相应的父节点的children中\n            toAppendNavList.forEach(_ => {\n                _ = Object.assign(_);\n                let parentNavIndex = this.getParentIndex(nav, _.index);\n                return this.appendToParentNav(retNavs, parentNavIndex, _);\n            });\n        }\n    });\n    //  此处的retNavs就是处理后的树\n    return retNavs;\n},\n//  处理属于同一级的标题，组成数组\nfind(arr, condition) {\n    return arr.filter(_ => {\n        for (let key in condition) {\n            if (condition.hasOwnProperty(key) && condition[key] !== _[key]) {\n                return false;\n            }\n        }\n        return true;\n    });\n},\n//  获取此节点的父节点\ngetParentIndex(nav, endIndex) {\n    //  从当前的index开始找 1.距离自己最近的（递减体现） 2.level比本身小的（越小越高）\n    for (var i = endIndex - 1; i >= 0; i--) {\n        if (nav[endIndex].level > nav[i].level) {\n            return nav[i].index;\n        }\n    }\n},\n//  找到同一个父节点的所有子节点\nappendToParentNav(nav, parentIndex, newNav) {\n    //  找到每一个二级标题的傅标题的index值\n    let index = this.findIndex(nav, {\n        index: parentIndex\n    });\n    nav[index].children = nav[index].children.concat(newNav);\n    //  如果要处理三级及以下标题，需要把每一个一级标题的children作为参数，调用appendToParentNav\n},\n//  找符合条件的数组中的成员\nfindIndex(arr, condition) {\n    let ret = -1;\n    arr.forEach((item, index) => {\n        for (var key in condition) {\n            if (condition.hasOwnProperty(key) && condition[key] !== item[key]) { // 不进行深比较\n                return false;\n            }\n        }\n        ret = index;\n    });\n    return ret;\n},\n```\n## md目录的展示和锚点定位\n```\n<div id="menu">\n    <ul class="nav-list">\n        <li v-for="(nav, index) in contentMenu" :key="index">\n            <a :href=""#" + nav.index" :class="{"active": highlightIndex === nav.index}" @click="handleHighlight(nav.index)" :key="nav.index">{{nav.title}}\n            </a>\n            <template v-if="nav.children.length > 0">\n                <ul class="nav-list">\n                    <li v-for="(item, index) in nav.children" :key="index">\n                        <a :href=""#" + item.index" :class="{active: highlightIndex === item.index}" :key="item.index" @click="handleHighlight(item.index)">{{item.title}}\n                        </a>\n                    </li>\n                </ul>\n            </template>\n        </li>\n    </ul>\n</div>\n```\n## 平滑滚动\n在md的目录中，a标签里已经设置了href值，进行了锚点定位，在点击目录绑定的事件里做了平滑处理\n```\nhandleHighlight(item) {\n    this.highlightIndex = item;\n    let jump = document.querySelectorAll(".jump");\n    //  这里的60是header的高度值\n    let total = jump[item].offsetTop - 60;\n    let distance = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;\n    // 平滑滚动，时长500ms，每10ms一跳，共50跳\n    let step = total / 50;\n    if (total > distance) {\n        smoothDown();\n    } else {\n        let newTotal = distance - total;\n        step = newTotal / 50;\n        smoothUp();\n    }\n    function smoothDown() {\n        if (distance < total) {\n            distance += step;\n            document.body.scrollTop = distance;\n            document.documentElement.scrollTop = distance;\n            setTimeout(smoothDown, 10);\n        } else {\n            document.body.scrollTop = total;\n            document.documentElement.scrollTop = total;\n        }\n    }\n    function smoothUp() {\n        if (distance > total) {\n            distance -= step;\n            document.body.scrollTop = distance;\n            document.documentElement.scrollTop = distance;\n            setTimeout(smoothUp, 10);\n        } else {\n            document.body.scrollTop = total;\n            document.documentElement.scrollTop = total;\n        }\n    }\n}\n```\n## 主内容滚动，目录高亮\n在阅读md内容时，随着滚动条的变化，目录的高亮项也随着变化\n```\nmounted() {\n    this.$nextTick(function() {\n        window.addEventListener("scroll", this.onScroll);\n    });\n},\nmethods: {\n    onScroll() {\n        let top = document.documentElement ? document.documentElement.scrollTop : document.body.scrollTop;\n        let items = document.getElementById("content").getElementsByClassName("jump");\n        let currentId = "";\n        for (let i = 0; i < items.length; i++) {\n            let _item = items[i];\n            let _itemTop = _item.offsetTop;\n            if (top > _itemTop - 75) {\n                currentId = _item.id;\n            } else {\n                break;\n            }\n        }\n        if (currentId) {\n            //  这里的currentOId是字符串，必须转换成数字，否则高亮项的全等无法匹配\n            this.highlightIndex = parseInt(currentId);\n        }\n    }\n}\n```\n ## Summary\n \n以上就是如何让md在网页上良好展示的全部功能，谷歌了多次，感谢分享经验的艾瑞巴dei，开源万岁～！ \n\n待改进的点有：\n- 如何避免非标题的井号的正则匹配，比如```// #这不是标题``` 格式的内容\n- md中h1和h2标签的处理，md中是允许html的，现在不能满足匹配h1、h2的标签\n'
export default str;